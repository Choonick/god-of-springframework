# 3장 템플릿

## 3.1 다시 보는 초난감 DAO

### JDBC 조회 기능의 예외처리

```JAVA
public int getCountO throws SQLException {
 Connection c = null；
 PreparedStatement ps = null；
 ResultSet rs = null；
 try {
  c = dataSource.getConnection()；
  ps = c.prepareStatement("select count(*) from users")；
  rs = ps.executeQueryQ；
  rs.nextO；
  return rs.getlnt(1)；
 } catch (SQLException e) {
  throw e；
 } finally {
  if (rs != null) {
   try {
    rs.closeO;
   } catch (SQLException e) {}
  }
  if (ps != null) {
   try {
    ps.closeO；
   } catch (SQLException e) {}
  }
  if (c != null) {
   try {
    c.closeO；
   } catch (SQLException e) {}
  }
 }
}
```

다음과 같은 코드에서 에러가 일어 날 수 있다.

```java
try {
  c = dataSource.getConnection()；
  ps = c.prepareStatement("select count(*) from users")；
  rs = ps.executeQueryQ；
  rs.nextO；
  return rs.getlnt(1)；
```

위의 상황이 발생하면 connection이 반환 되지않아 connection pool에 여유가 없어지고, 리소스가 모자란다는 오류를 발생 시킬 수 있다.

그래서 try/catch를 이용한 예외처리를 위와 같은 방법으로 해야한다.

### connection pool?	

- DB와 연결된 커넥션을 미리 만들어 pool에 저장해 두고 있다가 필요할 때 커넥션을 풀에서 쓰고 다시 풀에 반환하는 기법
- 사용자가 많아지면, db연결이 많이 일어나는데 DBCP와 같은 경우는 미리 DB와 연결된 객체를 만들어 놓고, 사용자가에 빌려주는 개념이다.
- 서버에는 동시접속자 수라는 한계가 있는데, 이를 넘어서면 client를 대기 상태로 전환시킨다. 이 후 connection pool에 connection이 돌아오면 대기자에게 connection을 준다.




## 3.2 변하는 것과 변하지 않는 것



### JDBC try/catch/finally의 문제점

- 너무 중괄호가 많고, 코드가 길어지면 헷갈린다. 이를 디자인 패턴으로 극복해보자


### 템플릿 메소드 패턴 

- 상위 클래스에서 처리의 흐름을 정의하고, 하위 클래스에서 처리 내용을 구체화 한다.

- 여러 클래스에서 사용되는 공통적인 부분은 상위 추상 클래스에서 구현하고, 각각 상세부분은 하위 클래스에서 구현한다.

  ```java
  public class UserDaoDeleteAll extends UserDao {
      protected PreparedStatement makeStatement(Connection c) throws SQLException {
          PreparedStatement ps = c.prepareStatement("delete from users")；
          return ps；
      }
  }
  ```



![1542345072839](C:\Users\USER\AppData\Roaming\Typora\typora-user-images\1542345072839.png)





### 전략패턴 - 실행 중에 알고리즘을 선택할 수 있게 한다.

- OCP를 잘지키는 구조이다.

- OCP

  - 확장에 대해 열려 있다. ( 새로운 동작을 추가해 모듈을 확장할 수 있다.)

  - 수정에 대해 닫혀 있다. ( 모듈의 소스코드나 바이너리를 수정하지 않아도, 기능을 확장하거나 변경할 수 있다.)


  ![예시이미지](https://t1.daumcdn.net/cfile/tistory/991A403359A419EC22)



  Strategy를 만들고, Strategy를 실행할 Context를 만든다.

### Strategy(interface)

```java
public interface Strategy {
    void runStrategy();
}
```



### ConcreteStrategyA,B

```java
public class StrategyGrenade implements Strategy{
 
    @Override
    public void runStrategy() {
        // TODO Auto-generated method stub
        System.out.println("수류탄 투척~! 쾅!!!!");
         
    }
 
}

public class StrategyGun implements Strategy{
 
    @Override
    public void runStrategy() {
        // TODO Auto-generated method stub
        System.out.println("탕! 타탕! 탕탕!");
         
    }
 
}
```



### Context

```java
public class Solider {
    void runContext(Strategy strategy) {
        System.out.println("배틀 그라운드 시작");
        strategy.runStrategy();
        System.out.println("배틀 종료");
    }
 
}
```



### Client

```java
public class Client {
 
    public static void main(String[] args) {
        Strategy strategy = null;
        Solider rambo = new Solider();
        strategy = new StrategyGun();
         
        rambo.runContext(strategy);
         
        System.out.println("\n");
        strategy = new StrategyGrenade();
         
        rambo.runContext(strategy);
    }
 
}
```



### Strategy와 template method pattern의 차이점???

- Strategy는 실행시간(clinent)에서 stategy를 상황에 맞게 변경할 수 있다.