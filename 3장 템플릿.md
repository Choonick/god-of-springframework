# 3장 템플릿

## 3.1 다시 보는 초난감 DAO

### JDBC 조회 기능의 예외처리

```JAVA
public int getCountO throws SQLException {
 Connection c = null；
 PreparedStatement ps = null；
 ResultSet rs = null；
 try {
  c = dataSource.getConnection()；
  ps = c.prepareStatement("select count(*) from users")；
  rs = ps.executeQueryQ；
  rs.nextO；
  return rs.getlnt(1)；
 } catch (SQLException e) {
  throw e；
 } finally {
  if (rs != null) {
   try {
    rs.closeO;
   } catch (SQLException e) {}
  }
  if (ps != null) {
   try {
    ps.closeO；
   } catch (SQLException e) {}
  }
  if (c != null) {
   try {
    c.closeO；
   } catch (SQLException e) {}
  }
 }
}
```

다음과 같은 코드에서 에러가 일어 날 수 있다.

```java
try {
  c = dataSource.getConnection()；
  ps = c.prepareStatement("select count(*) from users")；
  rs = ps.executeQueryQ；
  rs.nextO；
  return rs.getlnt(1)；
```

위의 상황이 발생하면 connection이 반환 되지않아 connection pool에 여유가 없어지고, 리소스가 모자란다는 오류를 발생 시킬 수 있다.

그래서 try/catch를 이용한 예외처리를 위와 같은 방법으로 해야한다.

### connection pool?	

- DB와 연결된 커넥션을 미리 만들어 pool에 저장해 두고 있다가 필요할 때 커넥션을 풀에서 쓰고 다시 풀에 반환하는 기법
- 사용자가 많아지면, db연결이 많이 일어나는데 DBCP와 같은 경우는 미리 DB와 연결된 객체를 만들어 놓고, 사용자가에 빌려주는 개념이다.
- 서버에는 동시접속자 수라는 한계가 있는데, 이를 넘어서면 client를 대기 상태로 전환시킨다. 이 후 connection pool에 connection이 돌아오면 대기자에게 connection을 준다.




## 3.2 변하는 것과 변하지 않는 것



### JDBC try/catch/finally의 문제점

- 너무 중괄호가 많고, 코드가 길어지면 헷갈린다. 이를 디자인 패턴으로 극복해보자


### 템플릿 메소드 패턴 

- 상위 클래스에서 처리의 흐름을 정의하고, 하위 클래스에서 처리 내용을 구체화 한다.

- 여러 클래스에서 사용되는 공통적인 부분은 상위 추상 클래스에서 구현하고, 각각 상세부분은 하위 클래스에서 구현한다.

  ```java
  public class UserDaoDeleteAll extends UserDao {
      protected PreparedStatement makeStatement(Connection c) throws SQLException {
          PreparedStatement ps = c.prepareStatement("delete from users")；
          return ps；
      }
  }
  ```



![1542345072839](C:\Users\USER\AppData\Roaming\Typora\typora-user-images\1542345072839.png)





### 전략패턴 - 실행 중에 알고리즘을 선택할 수 있게 한다.

- OCP를 잘지키는 구조이다.

- OCP

  - 확장에 대해 열려 있다. ( 새로운 동작을 추가해 모듈을 확장할 수 있다.)

  - 수정에 대해 닫혀 있다. ( 모듈의 소스코드나 바이너리를 수정하지 않아도, 기능을 확장하거나 변경할 수 있다.)


  ![예시이미지](https://t1.daumcdn.net/cfile/tistory/991A403359A419EC22)



  Strategy를 만들고, Strategy를 실행할 Context를 만든다.

### Strategy(interface)

```java
public interface Strategy {
    void runStrategy();
}
```



### ConcreteStrategyA,B

```java
public class StrategyGrenade implements Strategy{
 
    @Override
    public void runStrategy() {
        // TODO Auto-generated method stub
        System.out.println("수류탄 투척~! 쾅!!!!");
         
    }
 
}

public class StrategyGun implements Strategy{
 
    @Override
    public void runStrategy() {
        // TODO Auto-generated method stub
        System.out.println("탕! 타탕! 탕탕!");
         
    }
 
}
```



### Context

```java
public class Solider {
    void runContext(Strategy strategy) {
        System.out.println("배틀 그라운드 시작");
        strategy.runStrategy();
        System.out.println("배틀 종료");
    }
 
}
```



### Client

```java
public class Client {
 
    public static void main(String[] args) {
        Strategy strategy = null;
        Solider rambo = new Solider();
        strategy = new StrategyGun();
         
        rambo.runContext(strategy);
         
        System.out.println("\n");
        strategy = new StrategyGrenade();
         
        rambo.runContext(strategy);
    }
 
}
```



### Strategy와 template method pattern의 차이점???

- Strategy는 실행시간(clinent)에서 stategy를 상황에 맞게 변경할 수 있다.
- template와는 다르게 context의 전략을 바꿀 수 있다. 
- template는 새로운 전략을 짜려면 새로운 클래스를 만들어야 하지만, 아 모르겠다.



**Stategy pattern에서 어떤 Strategy를 선택할 것인지는 context를 사용하는 앞단의 client가 결정하는 것이 일반적이다**. 그래서 패턴을 적용하여 try/catch/finally를 제거한 코드는 다음과 같다.



### Concrete Strategy

```java
package springbook.user.dao;
public class DeleteAllStatement implements StatementStrategy {
 public PreparedStatement makePreparedStatement(Connection c) throws
 SQLException {
  PreparedStatement ps = c.prepareStatement("delete from users")；
  return ps；
 }
}
```



### Context(parameter로 strategy를 넣어준다.)

```java
public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws SQLException {
 Connection c = null；
 PreparedStatement ps = null；

 try {
  c = dataSource.getConnection()；
  ps = stmt.makePreparedStatement(c)；
  ps.executeUpdateO；
 } catch (SQLException e) {
  throw e；
 } finally {
  if (ps != null) {
   try {
    ps.closeO；
   } catch (SQLException e) {}
  }
  if (c != null) {
   try {
    c.closeO；
   } catch (SQLException e) {}
  }
 }
    
}
```



### Client

```java
public void deleteAllO throws SQLException {
 StatementStrategy st = new DeleteAllStatement();
 jdbcContextWithStatementStrategy(st)；
}
```



? DI랑 비슷하다고 하는데 아직 DI를 모른다.



## 3.2 JDBC 전략 패턴의 최적화

add()도 메소드도 마찬가지 이다. 다만 add할때 user의 정보가 필요하다. 그 부분은 생성자함수에 user정보를 parameter로 받아 해결한다.



### Contrete Strategy

```java
package springbook.user.dao；
public class AddStatement implements StatementStrategy {
 User user；
 public AddStatement(User user) {
  this.user = user；
 }
 public PreparedStatement makePreparedStatement(Connection c) {
  ps.setString(1, user.getldO)；
  ps.setString(2, user.getNameO)；
  ps.setString(3, user.getPasswordO)；
   ...
 }
}
```

위에는 2가지 불편한 점이 있다.

1. DAO메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다.
2. DAO메소드에서 user와 같은 전달받는 변수를 번거롭게 만들어야한다.



이 문제들은 내부 클래스를 만들어 내부클래스에서 외부 user변수를 접근하도록 하면 된다.



### Client ( client + contrete strategy)

```java
public void add(final User user) throws SQLException {
  class AddStatement implements StatementStrategy {
   public PreparedStatement makePreparedStatement(Connection c)
   throws SQLException {
    PreparedStatement ps = c.prepareStatement(
     "insert into users(id, name, password) values( ? , ? , ? )" )；
     ps.setString(1, user.getldO)； 
     ps.setString(2, user.getNameO)； 
     ps.setString(3, user.getPasswordO)； 
     return ps；     
   }
  }
     StatementStrategy st = new AddStatementO； 
     userS idbcContextWi thStatementStrategy(st)；
}
```



위에서 AddStatement클래스는 add()메소드에서만 사용할 수 있으므로 익명 내부클래스로 정의할 수 있다.

```java
StatementStrategy st = new StatementStrategyO {
 public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
  PreparedStatement ps =
   c.prepareStatement("insert into users(id, name, password) values( ? ? ? )");
  ps.setStringd, user.getld())；
  ps.setString(2, user.getName())；
  ps.setstring(3, user.getPassword())；
  return ps；
 }
}；
```



```java
public void add(final User user) throws SQLException {
 jdbcContextWithStatementStrategy(
  new StatementStrategy() {
   public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
    PreparedStatement ps =
     c.prepareStatement("insert into users(id, name,password) values( ? , ? , ? )");
    ps.setString(1, user.getldO)；
    ps.setString(2, user.getNameO)；
    ps.setstring(3, user.getPasswordO)；
    return ps；
   }
  }
 };
}
```

