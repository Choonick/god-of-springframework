# 3장 템플릿

## 3.1 다시 보는 초난감 DAO

### JDBC 조회 기능의 예외처리

```JAVA
public int getCountO throws SQLException {
 Connection c = null；
 PreparedStatement ps = null；
 ResultSet rs = null；
 try {
  c = dataSource.getConnection()；
  ps = c.prepareStatement("select count(*) from users")；
  rs = ps.executeQueryQ；
  rs.nextO；
  return rs.getlnt(1)；
 } catch (SQLException e) {
  throw e；
 } finally {
  if (rs != null) {
   try {
    rs.closeO;
   } catch (SQLException e) {}
  }
  if (ps != null) {
   try {
    ps.closeO；
   } catch (SQLException e) {}
  }
  if (c != null) {
   try {
    c.closeO；
   } catch (SQLException e) {}
  }
 }
}
```

다음과 같은 코드에서 에러가 일어 날 수 있다.

```java
try {
  c = dataSource.getConnection()；
  ps = c.prepareStatement("select count(*) from users")；
  rs = ps.executeQueryQ；
  rs.nextO；
  return rs.getlnt(1)；
```

위의 상황이 발생하면 connection이 반환 되지않아 connection pool에 여유가 없어지고, 리소스가 모자란다는 오류를 발생 시킬 수 있다.

그래서 try/catch를 이용한 예외처리를 위와 같은 방법으로 해야한다.

### connection pool?	

- DB와 연결된 커넥션을 미리 만들어 pool에 저장해 두고 있다가 필요할 때 커넥션을 풀에서 쓰고 다시 풀에 반환하는 기법
- 사용자가 많아지면, db연결이 많이 일어나는데 DBCP와 같은 경우는 미리 DB와 연결된 객체를 만들어 놓고, 사용자가에 빌려주는 개념이다.
- 서버에는 동시접속자 수라는 한계가 있는데, 이를 넘어서면 client를 대기 상태로 전환시킨다. 이 후 connection pool에 connection이 돌아오면 대기자에게 connection을 준다.



## 3.2 변하는 것과 변하지 않는 것



### JDBC try/catch/finally의 문제점

- 너무 중괄호가 많고, 코드가 길어지면 헷갈린다. 이를 디자인 패턴으로 극복해보자

### 템플릿 메소드 패턴 

- 상위 클래스에서 처리의 흐름을 정의하고, 하위 클래스에서 처리 내용을 구체화 한다.

- 여러 클래스에서 사용되는 공통적인 부분은 상위 추상 클래스에서 구현하고, 각각 상세부분은 하위 클래스에서 구현한다.

  ```java
  public class UserDaoDeleteAll extends UserDao {
      protected PreparedStatement makeStatement(Connection c) throws SQLException {
          PreparedStatement ps = c.prepareStatement("delete from users")；
          return ps；
      }
  }
  ```



![1542345072839](https://t1.daumcdn.net/cfile/tistory/1840353A507B6D4A29)





### 전략패턴 - 실행 중에 알고리즘을 선택할 수 있게 한다.

- OCP를 잘지키는 구조이다.
- OCP
  - 확장에 대해 열려 있다. ( 새로운 동작을 추가해 모듈을 확장할 수 있다.)
  - 수정에 대해 닫혀 있다. ( 모듈의 소스코드나 바이너리를 수정하지 않아도, 기능을 확장하거나 변경할 수 있다.)

  ![예시이미지](https://t1.daumcdn.net/cfile/tistory/991A403359A419EC22)



  Strategy를 만들고, Strategy를 실행할 Context를 만든다.

### Strategy(interface)

```java
public interface Strategy {
    void runStrategy();
}
```



### ConcreteStrategyA,B

```java
public class StrategyGrenade implements Strategy{
 
    @Override
    public void runStrategy() {
        // TODO Auto-generated method stub
        System.out.println("수류탄 투척~! 쾅!!!!");
         
    }
 
}

public class StrategyGun implements Strategy{
 
    @Override
    public void runStrategy() {
        // TODO Auto-generated method stub
        System.out.println("탕! 타탕! 탕탕!");
         
    }
 
}
```



### Context

```java
public class Solider {
    void runContext(Strategy strategy) {
        System.out.println("배틀 그라운드 시작");
        strategy.runStrategy();
        System.out.println("배틀 종료");
    }
 
}
```



### Client

```java
public class Client {
 
    public static void main(String[] args) {
        Strategy strategy = null;
        Solider rambo = new Solider();
        strategy = new StrategyGun();
         
        rambo.runContext(strategy);
         
        System.out.println("\n");
        strategy = new StrategyGrenade();
         
        rambo.runContext(strategy);
    }
 
}
```



### Strategy와 template method pattern의 차이점???

- Strategy는 실행시간(clinent)에서 stategy를 상황에 맞게 변경할 수 있다.
- template와는 다르게 context의 전략을 바꿀 수 있다. 
- template는 새로운 전략을 짜려면 새로운 클래스를 만들어야 하지만, 아 모르겠다.



**Stategy pattern에서 어떤 Strategy를 선택할 것인지는 context를 사용하는 앞단의 client가 결정하는 것이 일반적이다**. 그래서 패턴을 적용하여 try/catch/finally를 제거한 코드는 다음과 같다.



### Concrete Strategy

```java
package springbook.user.dao;
public class DeleteAllStatement implements StatementStrategy {
 public PreparedStatement makePreparedStatement(Connection c) throws
 SQLException {
  PreparedStatement ps = c.prepareStatement("delete from users")；
  return ps；
 }
}
```



### Context(parameter로 strategy를 넣어준다.)

```java
public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws SQLException {
 Connection c = null；
 PreparedStatement ps = null；

 try {
  c = dataSource.getConnection()；
  ps = stmt.makePreparedStatement(c)；
  ps.executeUpdateO；
 } catch (SQLException e) {
  throw e；
 } finally {
  if (ps != null) {
   try {
    ps.closeO；
   } catch (SQLException e) {}
  }
  if (c != null) {
   try {
    c.closeO；
   } catch (SQLException e) {}
  }
 }
    
}
```



### Client

```java
public void deleteAllO throws SQLException {
 StatementStrategy st = new DeleteAllStatement();
 jdbcContextWithStatementStrategy(st)；
}
```



? DI랑 비슷하다고 하는데 아직 DI를 모른다.



## 3.2 JDBC 전략 패턴의 최적화

add()도 메소드도 마찬가지 이다. 다만 add할때 user의 정보가 필요하다. 그 부분은 생성자함수에 user정보를 parameter로 받아 해결한다.



### Contrete Strategy

```java
package springbook.user.dao；
public class AddStatement implements StatementStrategy {
 User user；
 public AddStatement(User user) {
  this.user = user；
 }
 public PreparedStatement makePreparedStatement(Connection c) {
  ps.setString(1, user.getldO)；
  ps.setString(2, user.getNameO)；
  ps.setString(3, user.getPasswordO)；
   ...
 }
}
```

위에는 2가지 불편한 점이 있다.

1. DAO메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다.
2. DAO메소드에서 user와 같은 전달받는 변수를 번거롭게 만들어야한다.



이 문제들은 내부 클래스를 만들어 내부클래스에서 외부 user변수를 접근하도록 하면 된다.



### Client ( client + contrete strategy)

```java
public void add(final User user) throws SQLException {
  class AddStatement implements StatementStrategy {
   public PreparedStatement makePreparedStatement(Connection c)
   throws SQLException {
    PreparedStatement ps = c.prepareStatement(
     "insert into users(id, name, password) values( ? , ? , ? )" )；
     ps.setString(1, user.getldO)； 
     ps.setString(2, user.getNameO)； 
     ps.setString(3, user.getPasswordO)； 
     return ps；     
   }
  }
     StatementStrategy st = new AddStatementO； 
     userS idbcContextWi thStatementStrategy(st)；
}
```



위에서 AddStatement클래스는 add()메소드에서만 사용할 수 있으므로 익명 내부클래스로 정의할 수 있다.

```java
StatementStrategy st = new StatementStrategyO {
 public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
  PreparedStatement ps =
   c.prepareStatement("insert into users(id, name, password) values( ? ? ? )");
  ps.setStringd, user.getld())；
  ps.setString(2, user.getName())；
  ps.setstring(3, user.getPassword())；
  return ps；
 }
}；
```



```java
public void add(final User user) throws SQLException {
 jdbcContextWithStatementStrategy(
  new StatementStrategy() {
   public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
    PreparedStatement ps =
     c.prepareStatement("insert into users(id, name,password) values( ? , ? , ? )");
    ps.setString(1, user.getldO)；
    ps.setString(2, user.getNameO)；
    ps.setstring(3, user.getPasswordO)；
    return ps；
   }
  }
 };
}
```



## 3.4 컨텍스트와 DI

jdbcContextWithStatementStrategy() 는 다른 DAO에서도 사용 가능하다. 그래서 메소드를 UserDao 밖으로 독립시켜서 모든 DAO가 사용할 수 있게 해보자



### 클래스 분리

분리할 클래스 이름을 JdbcContext라고 한다. JdbcContextWithStatementStrategy() -> workWithStatementStrategy()라는 이름으로 바꾼다. 

이렇게 되면 DataSource가 필요한 것은 UserDao가 아니라 JdbcContext가 된다. 

그래서 JdbcContext가 DataSource에 의존하고 있으므로 DataSource 타입 빈을 DI 받을 수 있게 해야한다.



### JdbcContext

```java
package springbook.user.dao;
public class DdbcContext {

 private DataSource dataSource；
 public void setDataSource(DataSource dataSource) {
  this.dataSource = dataSource；
 }
 public void workWithStatementStrategy(StatementStrategy stmt) throws SQLException {
  Connection c = null；
  PreparedStatement ps = null；
  try {
   c = this.dataSource.getConnection()；
   ps = stmt.makePreparedStatement(c)；
   ps.executeUpdateO；
  } catch (SQLException e) {
   throw e；
  } finally {
   if (ps != null) {
    try {
     ps.closeO；
    } catch (SQLException e) {}
   }
   if (c != null) {
    try {
     c.closeO；
    } catch (SQLException e) {}
   }
  }
 }
}
```



### UserDao

```java
public class UserDao {
 ...
 private DdbcContext jdbcContext；
 public void set3dbcContext(JdbcContext jdbcContext) {
  this.jdbcContext = jdbcContext；
 }

 public void add(final User user) throws SQLException {
  this.jdbcContext.workWithStatementStrategy(
   new StatementStrategyO { ... }
  );
 }
    
 public void deleteAllO throws SQLException {
  this.jdbcContext.workWithStatementStrategy(
   new StatementStrategyO { ... }
  );
 }
    
}
```

UserDao가 JdbcContext에 의존하게 되면서 의존관계가 다음과 같이 변화하였다.

![이미지](https://user-images.githubusercontent.com/18159012/38455734-50830a28-3ab7-11e8-8a42-e5466b394980.png)

그래서 빈을 수정해주어야 한다.

## 리스트 3-23  p234



## 3.4.2 JdbcContext의 특별한 DI

UserDao와 JdbcContext 사이에는 인터페이스를 사용하지 않고 DI를 적용했다. 클래스 레벨에서 의존관계가 성립되었다. 기존의 인터페이스를 이용하여 결합성을 낮춘것과는 방법이 조금 다르다. 

그래서 온전한 DI라고 보기는 힘들지만, 스프링 DI는 객체생성과 관계설정에 대한 제어권을 외부로 위임했다는 IoC라는 개념을 포괄하기 때문에 DI의 기본을 따른다고 볼 수 있다.

인터페이스를 사용하지않고, DI 구조로 UserDao와 JdbcContext만들어야할 이유는 2가지 이다.

1. JdbcContext가 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤 빈이기 때문....
   - 스프링 빈으로 만들어 싱글톤으로 관리되는 것이 여러 오브젝트에서 공유될 수 있어서 이득이다.
2. JdbcContext가 DI를 통해 다른 빈에 의존하고 있기 때문..

**UserDao는 항상 JdbcContext클래스와 함께 사용되어야 한다. 함께 계속 결합되어 있다는것은 강한 응집도를 갖는다는 의미와 같다.**



JdbcContext를 스프링 빈으로 등록하지 않고, UserDao 내부에서 직접 DI를 구현하는 방법이 있다.



 





